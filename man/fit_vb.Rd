% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/growth.R
\name{fit_vb}
\alias{fit_vb}
\title{Fit a von Bertalanffy growth model}
\usage{
fit_vb(
  dat,
  sex = c("female", "male", "all"),
  method = c("tmb", "mpd", "mcmc"),
  downsample = Inf,
  chains = 4L,
  iter = 1000L,
  cores = parallel::detectCores(),
  allow_slow_mcmc = FALSE,
  est_method = median,
  min_samples = 50L,
  too_high_quantile = 1,
  uniform_priors = FALSE,
  ageing_method_codes = NULL,
  usability_codes = c(0, 1, 2, 6),
  check_convergence_tmb = TRUE,
  tmb_inits = list(k = 0.5, linf = 40, log_sigma = log(0.1), t0 = -1),
  ...
)
}
\arguments{
\item{dat}{Input data frame. Should be from \code{\link[=get_survey_samples]{get_survey_samples()}} or
\code{\link[=get_commercial_samples]{get_commercial_samples()}}.}

\item{sex}{Either "male" or "female".}

\item{method}{\code{"mpd"} for the mode of the posterior distribution (with
\code{\link[rstan:stanmodel-method-optimizing]{rstan::optimizing()}}) or \code{"mcmc"} for full MCMC sampling with Stan (with
\code{\link[rstan:stanmodel-method-sampling]{rstan::sampling()}}). \code{"tmb"} for a TMB model.}

\item{downsample}{If not \code{Inf} this represents a number of fish specimens to
sample prior to model fitting. Can be useful for large data sets that you
want to fit with MCMC for testing purposes.}

\item{chains}{Number of Stan chains.}

\item{iter}{Number of Stan sampling iterations.}

\item{cores}{Number of cores for Stan.}

\item{allow_slow_mcmc}{Logical. If \code{TRUE} then the function will let you fit
with MCMC to any number of fish. Defaults to \code{FALSE} to avoid accidentally
fitting a model to a giant data set (stop if number of fish > 50,000).}

\item{est_method}{If MCMC this defines how to summarize the posterior. Should
be a function such as \code{mean} or \code{median}.}

\item{min_samples}{The minimum number of fish before a model will be fit.}

\item{too_high_quantile}{A quantile above which to discard weights and
lengths. Can be useful for outliers. Defaults to including all data.}

\item{uniform_priors}{Logical. If true then uniform priors will be used.}

\item{ageing_method_codes}{A numeric vector of ageing method codes to filter
on. Defaults to \code{NULL}, which brings in all valid ageing codes. See
\code{\link[=get_age_methods]{get_age_methods()}}.}

\item{usability_codes}{An optional vector of usability codes.
All usability codes not in this vector will be omitted.
Set to \code{NULL} to include all samples.}

\item{check_convergence_tmb}{Logical.}

\item{tmb_inits}{A named list of initial parameter values for the TMB model.}

\item{...}{Any other arguments to pass on to \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling()}} or
\code{\link[rstan:stanmodel-method-optimizing]{rstan::optimizing()}}.}
}
\description{
For use with data for a single species.
}
\examples{
\donttest{
# with `rstan::optimizing()` for the mode of the posterior density:
model_f <- fit_vb(pop_samples, sex = "female")
model_m <- fit_vb(pop_samples, sex = "male")
plot_vb(model_f, model_m)
model_f$model
model_f$predictions

# You can also fit both sexes combined if you want.
# Just note that you need to specify the colours explicitly in the plot.
model_all <- fit_vb(pop_samples, sex = "all")
plot_vb(object_all = model_all, col = c("All" = "black"))

# with MCMC via Stan (slower):
x <- fit_vb(pop_samples, method = "mcmc",
  chains = 1, iter = 800, seed = 123) # just for a fast example
x$pars
x$predictions
x$data
x$model
posterior <- rstan::extract(x$model)
hist(posterior$linf)

# If less than `min_samples`, fit_vb() returns an empty object that
# plot_vb() will correctly parse and produce an empty plot:
obj <- fit_vb(pop_samples[1:2,])
plot_vb(obj, obj)
}
}
